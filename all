#include "list.h"

t_list		*sort_list(t_list* lst, int (*cmp)(int, int))
{
	t_list		*cur1;
	t_list		*cur2;
	int			tmp;

	tmp = 0;
	cur1 = lst;
	while (cur1)
	{
		cur2 = cur1->next;
		while (cur2)
		{
			if (cmp(cur1->data, cur2->data) != 1)
			{
				tmp = cur1->data;
				cur1->data = cur2->data;
				cur2->data = tmp;
			}
			cur2 = cur2->next;
		}
		cur1 = cur1->next;
	}
	return (lst);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 14:50:14 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:07:21 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	rotone(char *str)
{
	int	i;
	char	c;

	i = 0;
	while (str[i])
	{
	c = str[i];
	if (c >= 'a' && c <= 'y')
	c = c + 1;
	else if (c == 'z')
	c = 'a';
	if (c >= 'A' && c <= 'Y')
	c = c + 1;
	else if (c == 'Z')
	c = 'A';
	write(1, &c, 1);
	i++;
	}
}

int	main(int argc, char **argv)
{
	if (argc == 2)
	rotone(argv[1]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hidenp.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 15:03:44 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:07:27 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	hidenp(char *s1, char *s2)
{
	while (*s2)
	{
	if (*s1 && *s1 == *s2)
	s1++;
	s2++;
	}
	if (!*s1)
	write(1, "1", 1);
	else
	write(1, "0", 1);
}

int	main(int argc, char **argv)
{
	if (argc == 3)
	hidenp(argv[1], argv[2]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   union.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 15:14:28 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:07:46 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	ft_cmp(char c, char *s, int index)
{
	int	i;

	i = 0;
	while (s[i])
	{
	if (s[i] == c)
	break ;
	i++;
	}
	if (i == index)
	write(1, &s[i], 1);
}

void	ft_union(char *s1, char *s2)
{
	int	i;
	int	j;

	i = -1;
	while (s1[++i])
	ft_cmp(s1[i], s1, i);
	i = 0;
	while (s2[i])
	{
	j = 0;
	while (s1[j])
	{
	if (s2[i] == s1[j])
	break ;
	j++;
	}
	if (!s1[j])
	ft_cmp(s2[i], s2, i);
	i++;
	}
}

int	main(int argc, char **argv)
{
	if (argc == 3)
	ft_union(argv[1], argv[2]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   helpers.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 16:03:12 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:00:30 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ordalph.h"
#include <unistd.h>
#include <stdlib.h>

int	ft_strlen(char *s)
{
	int	i;

	i = 0;
	while (s[i])
	i++;
	return (i);
}

static void	ft_putstr(char *s)
{
	write(1, s, ft_strlen(s));
}

int	ft_strcmp(char *ss1, char *ss2)
{
	char	*s1;
	char	*s2;

	s1 = ft_tolower(ss1);
	s2 = ft_tolower(ss2);
	while (*s1 && *s2 && *s1 == *s2)
	{
	s1++;
	s2++;
	}
	return (*s1 - *s2);
}

static void	print_words(t_words *begin)
{
	while (begin)
	{
	ft_putstr(begin->str);
	if (begin->next)
	write(1, " ", 1);
	begin = begin->next;
	}
}

void	print(t_list *begin)
{
	while (begin)
	{
	print_words(begin->words);
	write(1, "\n", 1);
	begin = begin->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   list.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 15:57:17 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:01:22 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ordalph.h"
#include <stdlib.h>

t_words	*new_words(char *str)
{
	t_words	*words;

	if (!(words = (t_words *)malloc(sizeof(t_words))))
	return (NULL);
	words->str = str;
	words->next = NULL;
	return (words);
}

t_list	*new_list(int len, t_words *words)
{
	t_list	*list;

	if (!(list = (t_list *)malloc(sizeof(t_list))))
	return (NULL);
	list->words = words;
	list->len = len;
	list->next = NULL;
	return (list);
}

void	push_list(t_list **begin, t_list *new)
{
	t_list	*tmp;
	t_list	*prev;

	if ((*begin) == NULL)
	*begin = new;
	else
	{
	prev = NULL;
	tmp = *begin;
	while (tmp)
	{
	if (new && tmp->len > new->len)
	{
	new->next = tmp;
	break ;
	}
	prev = tmp;
	tmp = tmp->next;
	}
	if (prev)
	prev->next = new;
	else
	*begin = new;
	}
}

void	push_words(t_words **begin, t_words *new)
{
	t_words	*tmp;
	t_words	*prev;

	if ((*begin) == NULL)
	*begin = new;
	else
	{
	prev = NULL;
	tmp = *begin;
	while (tmp)
	{
	if (new && new->str && ft_strcmp(tmp->str, new->str) > 0)
	{
	new->next = tmp;
	break ;
	}
	prev = tmp;
	tmp = tmp->next;
	}
	if (prev)
	prev->next = new;
	else
	*begin = new;
	}
}

void	add_word(t_list **begin, char *str)
{
	t_list	*tmp;

	tmp = *begin;
	while (tmp)
	{
	if (tmp->len == ft_strlen(str))
	{
	push_words(&(tmp->words), new_words(str));
	return ;
	}
	tmp = tmp->next;
	}
	tmp = new_list(ft_strlen(str), new_words(str));
	push_list(begin, tmp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 15:47:24 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:01:38 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ordalph.h"
#include <unistd.h>

int	main(int argc, char **argv)
{
	if (argc == 2)
	ord_alphlong(argv[1]);
	else
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ordalph.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 15:52:49 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:02:22 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ordalph.h"
#include <stdlib.h>

static char	*ft_strdup(char *s, int start, int end)
{
	char	*new;
	int	i;

	if (s == NULL)
	return (NULL);
	new = (char *)malloc(sizeof(char) * (end - start + 1));
	i = start;
	while (i < end)
	{
	new[i - start] = s[i];
	i++;
	}
	new[i - start] = '\0';
	return (new);
}

int	ft_isalpha(char c)
{
	if (c >= 'a' && c <= 'z')
	return (1);
	if (c >= 'A' && c <= 'Z')
	return (1);
	if (c >= '0' && c <= '9')
	return (1);
	return (0);
}

char	*ft_tolower(char *s)
{
	char	*new;
	int	i;

	i = 0;
	new = (char *)malloc(sizeof(char) * (ft_strlen(s) + i));
	while (s[i])
	{
	if (s[i] >= 'A' && s[i] <= 'Z')
	new[i] = s[i] + 32;
	else
	new[i] = s[i];
	i++;
	}
	new[i] = '\0';
	return (new);
}

void	ord_alphlong(char *s)
{
	t_list	*begin;
	int	start;
	int	len;
	int	i;

	i = 0;
	start = 0;
	begin = NULL;
	while (s[i])
	{
	if (ft_isalpha(s[i]))
	{
	start = i;
	len = 0;
	while (s[i + len] && ft_isalpha(s[i + len]))
	len++;
	i += len;
	add_word(&begin, ft_strdup(s, start, i));
	}
	else
	i++;
	}
	print(begin);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ordalph.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/16 15:49:56 by exam              #+#    #+#             */
/*   Updated: 2014/01/16 18:02:50 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ORDALPH_H
# define ORDALPH_H

typedef struct	s_words
{
	char	*str;
	struct s_words	*next;
}	t_words;

typedef struct	s_list
{
	int	len;
	t_words	*words;
	struct s_list	*next;
}	t_list;

int	ft_strcmp(char *s1, char *s2);
int	ft_strlen(char *s);
void	print(t_list *begin);
char	*ft_tolower(char *s);

t_list	*new_list(int len, t_words *words);
t_words	*new_words(char *word);
void	push_list(t_list **begin, t_list *new);
void	push_words(t_words **begin, t_words *new);
void	add_word(t_list **begin, char *str);
void	ord_alphlong(char *s);

#endif /* !ORDALPH_H */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ulstr.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 14:33:22 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 14:40:29 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	ulstr(char *s)
{
	char	c;

	while (*s)
	{
	if (*s >= 'a' && *s <= 'z')
	c = *s - 32;
	else if (*s >= 'A' && *s <= 'Z')
	c = *s + 32;
	else
	c = *s;
	write(1, &c, 1);
	s++;
	}
}

int	main(int argc, char **argv)
{
	if (argc == 2)
	ulstr(argv[1]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wdmatch.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 14:41:25 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 14:46:18 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

int	ft_strlen(char *s)
{
	int	i;

	i = 0;
	while (s[i])
	i++;
	return (i);
}

void	wdmatch(char *s1, char *s2)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (s2[i])
	{
	if (s2[i] && s1[j] && s1[j] == s2[i])
	j++;
	i++;
	}
	if (!s1[j])
	write(1, s1, ft_strlen(s1));
}

int	main(int argc, char **argv)
{
	if (argc == 3)
	wdmatch(argv[1], argv[2]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 14:46:56 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 14:54:21 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_strlen(char *s)
{
	int	i;

	i = 0;
	while (s[i])
	i++;
	return (i);
}

char	*ft_strdup(char *src)
{
	char	*new;
	int	len;
	int	i;

	if (!src)
	return (NULL);
	len = ft_strlen(src);
	if (!(new = (char *)malloc(sizeof(char) * (len + 1))))
	return (NULL);
	i = -1;
	while (++i < len)
	new[i] = src[i];
	new[i] = '\0';
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   inter.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 14:55:21 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 15:18:23 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	fill_tab(char *s1, char *tab, int *max)
{
	int	i;

	while (*s1)
	{
	i = -1;
	while (++i < *max)
	{
	if (tab[i] == *s1)
	break ;
	}
	if (i == *max)
	*max = *max + 1;
	tab[i] = *s1;
	s1++;
	}
}

void	inter(char *s1, char *s2)
{
	char	t[255];
	int	i;
	int	j;
	int	max;

	i = -1;
	max = 0;
	while (++i < 255)
	t[i] = 0;
	fill_tab(s1, t, &max);
	i = -1;
	while (++i < max)
	{
	j = 0;
	while (s2[j])
	{
	if (s2[j] == t[i])
	{
	write(1, &t[i], 1);
	break ;
	}
	j++;
	}
	}
}

int	main(int argc, char **argv)
{
	if (argc == 3)
	inter(argv[1], argv[2]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   str_maxlenoc.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 15:19:18 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 16:26:21 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

int	ft_strlen(char *s)
{
	int	i;

	i = 0;
	while (s[i])
	i++;
	return (i);
}

int	ft_strstr(char *s1, char *s2, int n)
{
	int	i;

	if (!s1 || !s2)
	return (0);
	while (*s2)
	{
	i = 0;
	while (s1[i] && s2[i] && i < n)
	{
	if (s1[i] != s2[i])
	break ;
	i++;
	}
	if (i == n || !s1[i])
	return (1);
	s2++;
	}
	return (0);
}

void	str_maxlenoc(int nb, char **tab)
{
	char	*test;
	int	i_j_m_l_i[5] = {-1, -1, 0, 1, 0};

	test = tab[0];
	while (++i_j_m_l_i[1] < ft_strlen(tab[0]))
	{
	while (i_j_m_l_i[1] + i_j_m_l_i[3] <= ft_strlen(tab[0]))
	{
	i_j_m_l_i[0] = -1;
	while (++i_j_m_l_i[0] < nb)
	{
	if (!ft_strstr(&test[i_j_m_l_i[1]], tab[i_j_m_l_i[0]], i_j_m_l_i[3]))
	break ;
	}
	if (i_j_m_l_i[0] < nb)
	break ;
	if (i_j_m_l_i[3] > i_j_m_l_i[2])
	{
	i_j_m_l_i[2] = i_j_m_l_i[3];
	i_j_m_l_i[4] = i_j_m_l_i[1];
	}
	i_j_m_l_i[3]++;
	}
	}
	write(1, &test[i_j_m_l_i[4]], i_j_m_l_i[3] - 1);
}

int	main(int argc, char **argv)
{
	if (argc > 1)
	str_maxlenoc(argc - 1, &argv[1]);
	write(1, "\n", 1);
	return (0);
}
************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 16:27:46 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 17:51:50 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int	get_size(char *s, int *fd, int *size)
{
	char	buf[1024];
	int	l_nl[2] = {0, 0};
	int	ret;
	int	i;

	if (!s || (*fd = open(s, O_RDONLY)) < 0)
	return (0);
	while ((ret = read(*fd, buf, 1024)))
	{
	i = -1;
	while (++i < ret)
	{
	if (buf[i] == '\n')
	{
	if ((l_nl[0] != 0 && (i - l_nl[1]) % l_nl[0] != 0) || i > 1024)
	return (0);
	l_nl[0] = l_nl[0] ? i / (l_nl[1] + 1) : i;
	l_nl[1]++;
	}
	}
	*size += ret;
	}
	close(*fd);
	return (l_nl[0]);
}

void	find_island(char *map, int index, int s_sl[2], char *nbr)
{
	if (index > s_sl[0])
	return ;
	if (map[index] == 'X')
	{
	map[index] = *nbr;
	find_island(map, index + 1, s_sl, nbr);
	find_island(map, index + s_sl[1] + 1, s_sl, nbr);
	find_island(map, index - 1, s_sl, nbr);
	find_island(map, index - s_sl[1] - 1, s_sl, nbr);
	}
}

void	print_island(char *map, int size_line, int size)
{
	int	s_sl[2];
	int	i;
	char	nbr;

	nbr = '0';
	i = -1;
	s_sl[0] = size;
	s_sl[1] = size_line;
	while (++i < size)
	{
	if (map[i] == 'X')
	{
	find_island(map, i, s_sl, &nbr);
	nbr = nbr + 1;
	}
	}
	i = -1;
	write(1, map, size);
	if (map)
	free(map);
}

int	count_island(char *s)
{
	char	*map;
	int	size;
	int	fd;
	int	size_line;

	size = 0;
	if ((size_line = get_size(s, &fd, &size)) == 0)
	return (0);
	if (!size)
	return (0);
	if ((fd = open(s, O_RDONLY)) < 0)
	return (0);
	if (!(map = (char *)malloc(sizeof(char) * (size + 1))))
	return (0);
	map[size] = '\0';
	if ((read(fd, map, size)) < 0)
	return (0);
	print_island(map, size_line, size);
	close(fd);
	return (1);
}

int	main(int argc, char ** argv)
{
	if (argc == 2)
	{
	if (count_island(argv[1]) == 0)
	write(1, "\n", 1);
	}
	else
	write(1, "\n", 1);
	return (0);
}
....................................................
............XXXXXXXXX.X..........................XXX
............XXX....XXXX..........................XXX
XXXX........XXX......XXXXXX................XXXXXXXXX
XXX................XXXXXX..............XXXXXXXXXXX..
X...........................XX......................
........XXXX..............XXX.......................
XXXXXXXXXXXXXXX.................................XXXX
XXXXXXX.........................XXX............XXXXX
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   g_diam.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 17:52:33 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 18:22:28 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <stdlib.h>
#include "g_diam.h"

int	ft_atoi(char *s, int len)
{
	int	total;
	int	i;

	total = 0;
	i = -1;
	while (++i < len)
	total = total * 10 + s[i] - '0';
	return (total);
}

t_vertex	*new_vertex(t_vertex **graph, int val)
{
	t_vertex	*new;
	t_vertex	*tmp;

	tmp = *graph;
	while (tmp)
	{
	if (tmp->a == val)
	return (NULL);
	tmp = tmp->next;
	}
	new = (t_vertex *)malloc(sizeof(t_vertex));
	new->a = val;
	new->current = 0;
	new->next = NULL;
	if (*graph == NULL)
	*graph = new;
	else
	tmp = new;
	return (new);
}

void	g_diam(char *s)
{
	t_vertex	*graph;
	t_vertex	*tmp;
	int	i;

	graph = NULL;
	tmp = graph;
	while (*s)
	{
	i = 0;
	while (s[i] && s[i] >= '0' && s[i] <= '9')
	i++;
	tmp = new_vertex(&graph, ft_atoi(s, i));
	s += i + 1;
	i = 0;
	while (s[i] && s[i] >= '0' && s[i] <= '9')
	i++;
	if (tmp)
	{
	tmp->b[tmp->current] = ft_atoi(s, i);
	tmp->current++;
	}
	s += i + 1;
	tmp = tmp->next;
	}
}

int	main(int argc, char ** argv)
{
	if (argc == 2)
	write(1, "\n", 1);
	//g_diam(argv[1]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   g_diam.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/01/30 17:53:45 by exam              #+#    #+#             */
/*   Updated: 2014/01/30 18:20:06 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef G_DIAM_H
# define G_DIAM_H

# define MAX	1024	

typedef struct	s_vertex
{
	int	a;
	int	b[MAX];
	int	current;
	int	prev[MAX];
	struct s_vertex	*next;
}	t_vertex;

#endif /* !G_DIAM_H */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   str_capitalizer.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/02/20 14:33:33 by exam              #+#    #+#             */
/*   Updated: 2014/02/20 14:52:06 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

void	parse_str(char *s)
{
	int	i;
	char	c;

	i = 0;
	while (s[i])
	{
	while (s[i] && (s[i] == ' ' || s[i] == '\t'))
	{
	write(1, &s[i], 1);
	i++;
	}
	if (!s[i])
	return ;
	if (s[i] >= 'a' && s[i] <= 'z')
	c = s[i++] - 32;
	else
	c = s[i++];
	write(1, &c, 1);
	while (s[i] && s[i] != ' ' && s[i] != '\t')
	{
	if (s[i] >= 'A' && s[i] <= 'Z')
	c = s[i] + 32;
	else
	c = s[i];
	write(1, &c, 1);
	i++;
	}
	}
}

void	str_capitalizer(int nb, char **tab)
{
	int	i;

	i = -1;
	while (++i < nb)
	{
	parse_str(tab[i]);
	write(1, "\n", 1);
	}
}

int	main(int argc, char **argv)
{
	if (argc > 1)
	str_capitalizer(argc - 1, &argv[1]);
	else
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_rrange.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/02/20 14:52:44 by exam              #+#    #+#             */
/*   Updated: 2014/02/20 15:16:50 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

int	ft_abs(int i)
{
	if (i < 0)
	return (-i);
	return (i);
}

int	*ft_range(int start, int end)
{
	int	*tab;
	int	i;

	i = 0;
	while ((start + i) <= end)
	i++;
	if (!(tab = (int *)malloc(sizeof(int) * i)))
	return (NULL);
	i = -1;
	while ((start  + ++i) <= end)
	tab[i] = start + i;
	return (tab);
}

int	*ft_rangei(int start, int end)
{
	int	*tab;
	int	i;

	i = 0;
	while ((start + i) <= end)
	i++;
	if (!(tab = (int *)malloc(sizeof(int) * i)))
	return (NULL);
	i = -1;
	while ((end - ++i) >= start)
	tab[i] = end - i;
	return (tab);
}

int	*ft_rrange(int start, int end)
{
	if (start < end)
	return (ft_rangei(start, end));
	return (ft_range(end, start));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rev_wstr.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/02/20 15:17:41 by exam              #+#    #+#             */
/*   Updated: 2014/02/20 15:32:49 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

// bonjour je suis pas beau 
void	rev_wstr(char *s, int first)
{
	int	start;
	int	i;

	i = 0;
	if (s[i])
	{
	while (s[i] && (s[i] == ' ' || s[i] == '\t'))
	i++;
	if (!s[i])
	return ;
	start = i;
	while (s[i] && s[i] != ' ' && s[i] != '\t')
	i++;
	rev_wstr(&s[i], 0);
	write(1, &s[start], i - start);
	if (!first)
	write(1, " ", 1);
	}
}

int	main(int argc, char **argv)
{
	if (argc == 2)
	rev_wstr(argv[1], 1);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rsort_params.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/02/20 15:34:19 by exam              #+#    #+#             */
/*   Updated: 2014/02/20 16:55:35 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

int	ft_strcmp(char *s1, char *s2)
{
	while (*s1 && *s2)
	{
	if (*s1 != *s2)
	{
	if (*s1 > *s2)
	return (-1);
	return (1);
	}
	s1++;
	s2++;
	}
	return (*s2 - *s1);
}

void	ft_putstr(char *s)
{
	int	i;

	i = -1;
	while (s[++i])
	write(1, &s[i], 1);
	write(1, "\n", 1);
}

void	rsort_param(int nb, char **tab)
{
	char	*tmp;
	int	i;

	i = 0;
	while (i < nb - 1)
	{
	if (ft_strcmp(tab[i], tab[i + 1]) > 0)
	{
	tmp = tab[i];
	tab[i] = tab[i + 1];
	tab[i + 1] = tmp;
	i = 0;
	}
	else
	i++;
	}
	i = -1;
	while (++i < nb)
	ft_putstr(tab[i]);
}

int	main(int argc, char **argv)
{
	if (argc > 1)
	rsort_param(argc - 1, &argv[1]);
	else
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   infin_add.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/02/20 15:53:25 by exam              #+#    #+#             */
/*   Updated: 2014/02/20 18:24:00 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>

int	ft_strlen(char *s)
{
	int	len;

	len = 0;
	while (s[len])
	len++;
	return (len);
}

int	ft_strcmp(char *s1, char *s2)
{
	while (*s1 && *s2)
	{
	if (*s1 != *s2)
	{
	if (*s1 > *s2)
	return (-1);
	return (1);
	}
	s1++;
	s2++;
	}
	return (*s2 - *s1);
}

int	get_value(char c1, char c2, int ret, char *c)
{
	char	tmp;

	tmp = c1 + c2 - '0' + ret;
	ret = 0;
	if (tmp > '9')
	{
	tmp = tmp - 10;
	ret = 1;
	}
	*c = tmp;
	return (ret);
}

void	rec_add(char *s1, char *s2, int len1, int len2, int ret)
{
	char	tmp;
	int	r;

	if (len1 >= 0 && len2 >= 0)
	{
	r = get_value(s1[len1], s2[len2], ret, &tmp);
	rec_add(s1, s2, --len1, --len2, r);
	}
	else if (len1 >= 0)
	{
	r = get_value(s1[len1], '0', ret, &tmp);
	rec_add(s1, s2, --len1, --len2, r);
	}
	else if (len2 >= 0)
	{
	r = get_value('0', s2[len2], ret, &tmp);
	rec_add(s1, s2, --len1, --len2, r);
	}
	else
	{
	if (ret)
	write(1, "1", 1);
	return ;
	}
	write(1, &tmp, 1);
}

int	get_sub_value(char c1, char c2, int ret, char *c)
{
	char	tmp;

	tmp = c1 - c2 - ret;
	if (tmp < 0)
	{
	tmp = tmp + 10;
	ret = 1;
	}
	else
	ret = 0;
	*c = tmp;
	return (ret);
}

void	rec_sub(char *s1, char *s2, int len1, int len2, int ret, int first)
{
	char	tmp;

	if (len1 >= 0 && len2 >= 0)
	{
	ret = get_sub_value(s1[len1], s2[len2], ret, &tmp);
	if (len1 == 0 && len2 == 0 && tmp == 0)
	first = 1;
	else
	first = 0;
	rec_sub(s1, s2, --len1, --len2, ret, first);
	}
	else if (len1 >= 0)
	{
	ret = get_sub_value(s1[len1], '0', ret, &tmp);
	if (len1 == 0 && tmp == 0)
	first = 1;
	else
	first = 0;
	rec_sub(s1, s2, --len1, --len2, ret, first);
	}
	else if (len2 >= 0)
	{
	ret = get_sub_value('0', s2[len2], ret, &tmp);
	if (len2 == 0 && tmp == 0)
	first = 1;
	else
	first = 0;
	rec_sub(s1, s2, --len1, --len2, ret, first);
	}
	else
	return ;
	if (first)
	return ;
	tmp += '0';
	write(1, &tmp, 1);
}

void	infin_add(char *s1, char *s2)
{
	int	len1;
	int	len2;

	if (!s1 || !s2)
	return ;
	len1 = ft_strlen(s1) - 1;
	len2 = ft_strlen(s2) - 1;
	if (s1[0] == '-' && s2[0] == '-')
	{
	write(1, "-", 1);
	rec_add(&s1[1], &s2[1], len1 - 1, len2 - 1, 0);
	}
	else if (s1[0] == '-')
	{
	if (len1 - 1 > len2 || (len1 - 1 == len2 && ft_strcmp(s1, &s2[1]) < 0))
	{
	write(1, "-", 1);
	rec_sub(&s1[1], s2, len1 - 1, len2, 0, 1);
	}
	else
	rec_sub(s2, &s1[1], len2, len1 - 1, 0, 1);
	}
	else if (s2[0] == '-')
	{
	if (len2 - 1 > len1 || (len2 - 1 == len1 && ft_strcmp(&s2[1], s1) < 0))
	{
	write(1, "-", 1);
	rec_sub(&s2[1], s1, len2 - 1, len1, 0, 1);
	}
	else
	rec_sub(s1, &s2[1], len1, len2 - 1, 0, 1);
	}
	else
	rec_add(s1, s2, len1, len2, 0);
}

int	main(int argc, char **argv)
{
	if (argc == 3)
	infin_add(argv[1], argv[2]);
	write(1, "\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   g_diam.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/03/06 14:41:15 by exam              #+#    #+#             */
/*   Updated: 2014/03/06 17:11:20 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef G_DIAM_H
# define G_DIAM_H

typedef struct	s_node
{
	int	val;
	int	*neigh;
	int	visited;
	int	nb_neigh;
}	t_node;

typedef struct	s_list
{
	t_node	*node;
	struct s_list	*next;
}	t_list;

typedef struct	s_path
{
	int	*nodes;
	int	nb_visited;
	int	max;
}	t_path;

t_node	*new_node(int val);
t_list	*new_list(t_node *node);
void	add_node(t_list **begin, t_node *new);
t_list	*find_node(t_list *begin, int val);
int	ft_atoi(char *s, int len);
int	define_nodes(t_list **begin, char *s);
void	add_path(t_list *begin, int fir, int sec);
void	define_neigh(t_list *begin, char *s);
void	malloc_paths(t_list *begin, int nb_node);
void	find_path(t_list *list, t_list *cur, t_path *path);

#endif /* G_DIAM_H */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: exam <marvin@42.fr>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2014/03/06 14:38:22 by exam              #+#    #+#             */
/*   Updated: 2014/03/06 17:07:23 by exam             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <stdlib.h>
#include "g_diam.h"

t_node	*new_node(int val)
{
	t_node	*node;

	if (!(node = (t_node *)malloc(sizeof(t_node))))
	return (NULL);
	node->val = val;
	node->visited = 0;
	node->nb_neigh = 0;
	return (node);
}

t_list	*new_list(t_node *node)
{
	t_list	*list;

	if (!(list = (t_list *)malloc(sizeof(t_list))))
	return (NULL);
	list->node = node;
	list->next = NULL;
	return (list);
}

void	add_node(t_list **begin, t_node *new)
{
	t_list	*tmp;

	if (*begin == NULL)
	*begin = new_list(new);
	else
	{
	tmp = *begin;
	while (tmp->next)
	tmp = tmp->next;
	tmp->next = new_list(new);
	}
}

t_list	*find_node(t_list *begin, int val)
{
	t_list	*tmp;

	tmp = begin;
	while (tmp)
	{
	if (tmp->node->val == val)
	return (tmp);
	tmp = tmp->next;
	}
	return (NULL);
}

int	ft_atoi(char *s, int len)
{
	int	total;
	int	i;

	total = 0;
	i = -1;
	while (s[++i] && i < len)
	total = total * 10 + s[i] - '0';
	return (total);
}

int	define_nodes(t_list **begin, char *s)
{
	int	start;
	int	nb;
	int	i;
	int	nb_node;

	i = 0;
	nb_node = 0;
	while (s[i])
	{
	start = i;
	while (s[i] >= '0' && s[i] <= '9')
	i++;
	nb = ft_atoi(&s[start], i - start);
	if (!find_node(*begin, nb))
	{
	nb_node++;
	add_node(begin, new_node(nb));
	}
	if (!s[i])
	break ;
	i++;
	}
	return (nb_node);
}

void	add_path(t_list *begin, int fir, int sec)
{
	t_list	*tmp;
	int	i;

	if (!(tmp = find_node(begin, fir)))
	return ;
	i = -1;
	while (++i < tmp->node->nb_neigh)
	{
	if (tmp->node->neigh[i] == sec)
	return ;
	}
	tmp->node->neigh[tmp->node->nb_neigh] = sec;
	tmp->node->nb_neigh++;
	if (!(tmp = find_node(begin, sec)))
	return ;
	tmp->node->neigh[tmp->node->nb_neigh] = fir;
	tmp->node->nb_neigh++;
}

void	define_neigh(t_list *begin, char *s)
{
	int	start;
	int	i;
	int	fir;
	int	sec;

	i = 0;
	while (s[i])
	{
	start = i;
	while (s[i] >= '0' && s[i] <= '9')
	i++;
	fir = ft_atoi(&s[start], i - start);
	i++;
	start = i;
	while (s[i] >= '0' && s[i] <= '9')
	i++;
	sec = ft_atoi(&s[start], i - start);
	add_path(begin, fir, sec);
	if (!s[i])
	break ;
	i++;
	}
}

void	malloc_paths(t_list *begin, int nb_node)
{
	t_list	*tmp;
	int	i;

	tmp = begin;
	while (tmp)
	{
	tmp->node->neigh = (int *)malloc(sizeof(int) * nb_node - 1);
	i = -1;
	while (++i < nb_node)
	tmp->node->neigh[i] = -1;
	tmp = tmp->next;
	}
}

int	visited(t_path *path, int val)
{
	int	i;

	i = -1;
	while (++i < path->nb_visited)
	{
	if (path->nodes[i] == val)
	return (1);
	}
	return (0);
}

void	find_path(t_list *begin, t_list *cur, t_path *path)
{
	int	i;

	path->nodes[path->nb_visited] = cur->node->val;
	path->nb_visited++;
	if (path->nb_visited > path->max)
	path->max = path->nb_visited;
	i = -1;
	while (++i < cur->node->nb_neigh)
	{
	if (!visited(path, cur->node->neigh[i]))
	find_path(begin, find_node(begin, cur->node->neigh[i]), path);
	}
	cur = cur->next;
	path->nb_visited--;
}

void	ft_putnbr(int n)
{
	char	c;

	if (n / 10  > 0)
	ft_putnbr(n / 10);
	c = n % 10 + '0';
	write(1, &c, 1);
}

void	free_all(t_list *begin, t_path *path)
{
	t_list	*tmp;

	while (begin)
	{
	tmp = begin;
	begin = begin->next;
	free(tmp->node->neigh);
	free(tmp->node);
	free(tmp);
	}
	if (path)
	{
	free(path->nodes);
	free(path);
	}
}

void	g_diam(char *s)
{
	t_path	*path;
	t_list	*list;
	t_list	*tmp;
	int	nb_node;

	list = NULL;
	nb_node = define_nodes(&list, s);
	malloc_paths(list, nb_node);
	define_neigh(list, s);
	path = (t_path *)malloc(sizeof(t_path));
	path->nodes = (int *)malloc(sizeof(int) * nb_node);
	path->nb_visited = 0;
	path->max = 0;
	tmp = list;
	while (tmp)
	{
	find_path(list, tmp, path);
	tmp = tmp->next;
	}
	ft_putnbr(path->max);
	free_all(list, path);
}

int	main(int argc, char **argv)
{
	if (argc == 2)
	g_diam(argv[1]);
	write(1, "\n", 1);
	return (0);
}